<HTML><base href="http://developer.android.com/reference/android/widget/TextView.html#addTextChangedListener(android.text.TextWatcher)"><style type="text/css"> ul.inheritance {
margin:0;
padding:0;
}
ul.inheritance li {
display:inline;
list-style-type:none;
}
ul.inheritance li ul.inheritance {
margin-left:15px;
padding-left:15px;
padding-top:1px;
}
</style> <h3><a href="psi_element://android.widget.TextView"><code>android.widget.TextView</code></a></h3>
<div class="api-level">
  <div>
    Added in <a href="http://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels">API level 1</a>
  </div>

</div>
<pre class="api-signature no-pretty-print" translate="no" dir="ltr">
public void addTextChangedListener (<a href="http://developer.android.com/reference/android/text/TextWatcher">TextWatcher</a> watcher)</pre>

<p>Adds a TextWatcher to the list of those whose methods are called
  whenever this TextView's text changes.
<p>
  In 1.0, the <code translate="no" dir="ltr"><a href="http://developer.android.com/reference/android/text/TextWatcher#afterTextChanged(android.text.Editable)">TextWatcher#afterTextChanged</a></code> method was erroneously
  not called after <code translate="no" dir="ltr"><a href="http://developer.android.com/reference/android/widget/TextView#setText(char[],%20int,%20int)">setText(char, int, int)</a></code> calls. Now, doing <code translate="no" dir="ltr"><a href="http://developer.android.com/reference/android/widget/TextView#setText(char[],%20int,%20int)">setText(char, int, int)</a></code>
  if there are any text changed listeners forces the buffer type to
  Editable if it would not otherwise be and does call this method.</p></p>
<table class="responsive">
  <tr><th colspan=2>Parameters</th></tr>
  <tr>
    <td><code translate="no" dir="ltr">watcher</code></td>
    <td width="100%">
      <code translate="no" dir="ltr">TextWatcher</code> <!-- no parameter comment --></p></td>
  </tr>
</table>

</div>

<div data-version-added="1">
</HTML>