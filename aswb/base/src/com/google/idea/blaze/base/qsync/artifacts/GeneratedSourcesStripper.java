/*
 * Copyright 2024 The Bazel Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.idea.blaze.base.qsync.artifacts;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.io.ByteSource;
import com.google.idea.blaze.base.qsync.AnnotationProcessorOverride;
import com.google.idea.blaze.common.artifact.CachedArtifact;
import com.google.idea.blaze.qsync.artifacts.FileTransform;
import com.intellij.lang.java.JavaLanguage;
import com.intellij.lang.jvm.annotation.JvmAnnotationAttribute;
import com.intellij.lang.jvm.annotation.JvmAnnotationConstantValue;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.ThrowableComputable;
import com.intellij.psi.PsiAnnotation;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiFileFactory;
import com.intellij.psi.PsiImportStatement;
import com.intellij.psi.PsiJavaFile;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Enumeration;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;
import javax.annotation.Nullable;

/**
 * Removes source files with classes annotated with {@link javax.annotation.processing.Generated}
 * and that match given values.
 *
 * <p>This is used to remove source files generated by specific annotation processors (java plugins)
 * to prevent them conflicting with light classes generated by other plugins.
 */
public class GeneratedSourcesStripper implements FileTransform {

  private static final String GENERATED_ANNOTATION_FQCN = "javax.annotation.processing.Generated";

  private final Project project;

  public GeneratedSourcesStripper(Project project) {
    this.project = project;
  }

  @Override
  public ImmutableSet<Path> copyWithTransform(CachedArtifact src, Path dest) throws IOException {
    removeSourcesWithMatchingAnnotations(src, dest);
    return ImmutableSet.of(dest);
  }

  private void removeSourcesWithMatchingAnnotations(CachedArtifact src, Path dest)
      throws IOException {
    ImmutableSet<String> annotationProcessorsToStrip =
        AnnotationProcessorOverride.getAllAnnotationProcessorOverrides();
    Map<String, String> strippedCountByProcessor = Maps.newHashMap();
    try (ZipFile srcZip = src.openAsZipFile();
        ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(dest))) {
      Enumeration<? extends ZipEntry> entries = srcZip.entries();
      while (entries.hasMoreElements()) {
        ZipEntry entry = entries.nextElement();
        boolean keep = true;
        byte[] contents;
        try (InputStream zis = srcZip.getInputStream(entry)) {
          contents = zis.readAllBytes();
        }
        if (!entry.isDirectory()) {
          if (entry.getName().endsWith(".java")) {
            String generatedBy = getGeneratedValue(entry.getName(), ByteSource.wrap(contents));
            if (generatedBy != null && annotationProcessorsToStrip.contains(generatedBy)) {
              strippedCountByProcessor.put(entry.getName(), generatedBy);
              keep = false;
            }
          }
        }
        if (keep) {
          try {
            zos.putNextEntry(entry);
            zos.write(contents);
          } finally {
            zos.closeEntry();
          }
        }
      }
      if (!strippedCountByProcessor.isEmpty()) {
        // Write information about what sources were removed and why to aid debugging later on.
        ZipEntry strippedInfo = new ZipEntry(".stripped-sources");
        try {
          zos.putNextEntry(strippedInfo);
          zos.write(
              ("Sources removed by "
                      + getClass().getCanonicalName()
                      + ":\n"
                      + strippedCountByProcessor.entrySet().stream()
                          .map(
                              e ->
                                  String.format("%s: @Generated(\"%s\")", e.getKey(), e.getValue()))
                          .collect(Collectors.joining("\n")))
                  .getBytes(StandardCharsets.UTF_8));
        } finally {
          zos.closeEntry();
        }
      }
    }
  }

  @Nullable
  @VisibleForTesting
  String getGeneratedValue(String fileName, ByteSource content) throws IOException {
    return ApplicationManager.getApplication()
        .runReadAction(
            (ThrowableComputable<String, IOException>) () -> getInReadAction(fileName, content));
  }

  /**
   * Reads and return the {@code value} from a {@link javax.annotation.processing.Generated}
   * annotation of a class in a source file, or null if there is none.
   */
  private String getInReadAction(String fileName, ByteSource content) throws IOException {
    PsiFile psiFile =
        PsiFileFactory.getInstance(project)
            .createFileFromText(
                fileName,
                JavaLanguage.INSTANCE,
                content.asCharSource(StandardCharsets.UTF_8).read());
    if (!(psiFile instanceof PsiJavaFile)) {
      return null;
    }
    PsiJavaFile javaFile = (PsiJavaFile) psiFile;
    PsiImportStatement generatedImport =
        javaFile.getImportList().findSingleClassImportStatement(GENERATED_ANNOTATION_FQCN);
    for (PsiClass cls : javaFile.getClasses()) {
      PsiAnnotation generatedAnnotation = cls.getAnnotation(GENERATED_ANNOTATION_FQCN);
      if (generatedAnnotation == null && generatedImport != null) {
        // Due to the way we create the PsiFile, import annotation names seems not to be
        // automatically resolved. So we check for the qualified and unqualified annotations to make
        // sure we get it.
        generatedAnnotation =
            cls.getAnnotation(
                GENERATED_ANNOTATION_FQCN.substring(
                    GENERATED_ANNOTATION_FQCN.lastIndexOf('.') + 1));
      }
      if (generatedAnnotation != null) {
        String value =
            Optional.ofNullable(generatedAnnotation.findAttribute("value"))
                .map(JvmAnnotationAttribute::getAttributeValue)
                .filter(JvmAnnotationConstantValue.class::isInstance)
                .map(JvmAnnotationConstantValue.class::cast)
                .map(JvmAnnotationConstantValue::getConstantValue)
                .map(Object::toString)
                .orElse(null);
        if (value != null) {
          return value;
        }
      }
    }
    return null;
  }
}
